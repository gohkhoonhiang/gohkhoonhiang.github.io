---
layout: post
title:  Human Resource Machine Interpreter
date: 2016-05-23 20:23:21 +0800
tags: [python, project]
description: This post is about the interpreter I wrote for Human Resource Machine game.
---

I recently bought a game from Humble Bundle. I don't usually play games, but when I do, it's a programming game. :P Anyway, this [game](https://tomorrowcorporation.com/humanresourcemachine) is made by Tomorrow Corporation. I had a lot of things to do after I bought the game, when I finally got some time to start playing, it got me hooked, and I couldn't stop until I have completed all but one difficult level.

My mentor has also played this game, actually he was the one who introduced me this game, so he challenged me to write an interpreter of the HRM instructions. With some hints from him, I took up the challenge and wrote the interpreter within a night. It's far from polished, there are things I haven't considered and handled, but it's the process that is fun that makes this a project worthy of some airtime here.

<!-- more -->

# Things to Simulate

There are a few things to simulate from the HRM game. I will list each one and explain how I handle that in my interepreter.

## Inbox

There is a inbox where the main character is supposed to take input from. In my interpreter, I will use a list for the inbox. The list is read from a file as space-separated values, and will be stored in a list, like this:

```
inputs = [1,2,3,4,5,6,7]
```

will mean that the inbox has the following items (visually):

```
[1]
[2]
[3]
[4]
[5]
[6]
[7]
```

One thing to note is that when the input is read from a file, integers are in string format, so I will convert them into integer type and store in the list.

## Outbox

There is an outbox where the main character is supposed to put the result to. In my interepreter, I will use a list for the outbox, like this:

```
outputs = [1,2,3,4,5,6,7]
```
 
will mean that the outbox has the following items (visually):

```
[1]
[2]
[3]
[4]
[5]
[6]
[7]
```
The list is printed at the end of interepreting a set of instructions.
 
## Main Character

I sort of only realized who the main character is supposed to be after I started writing the interpreter, she's the temporary variable (the formal term to describe her role is actually accumulator according to the game website)! So I assign her as `x` in the interpreter.

Everytime the main character holds something in her hand, it's like doing `x = 1`.

## On the Floor Space

In later stages, they introduced on-the-floor storage space. The main character can get something from the inbox, then put it on the floor temporarily. She can get a copy from the floor back to her hands, and bring it to somewhere, for example, the outbox. 

The amount of memory available and constants will be defined in the file for initializing the VM like this:

```
3
0
```

The interpreter will then create a memory list with exactly 3 slots, with `0` as one of the constants like this:

```
mem = [None, None, 0]
```

will mean that on-the-floor space has the following items (visually):

```
[ ] [ ] [0]
```

The index written in each on-the-floor slot corresponds to the list index of the `mem` variable.

Note that constants are assigned to the memory starting from the end of the memory list.

## Commands

The commands that players like me design will be represented as a list of instructions which I read from a file, like this:

```
a:
    INBOX
    OUTBOX
    JUMP a
    END
```

This is actually the set of instructions generated by HRM if you use the `Copy` action from the commands clipboard and paste to any text editor. The only difference is that I added the `END` instruction in order for my interpreter to work properly.

The list containing the instructions will be created after reading from the file:

```
commands = ["a:","INBOX","OUTBOX","JUMP a","END"]
```

## Instruction Pointer

In the game, there is a pointer that runs through the commands on the clipboard. I represent this as a `ptr` variable in the interpreter. Each time I need to step through a command, I will increment the `ptr`, and I will directly set the `ptr` in cases like `JUMP`.

## Comments and Labels

In the plain text version of the HRM commands, there are some `DEFINE` instructions at the end of the actual instructions. They are there more for the visual display of labels and comments in game, and does not interfere with the actual interpreting logic, so I have conveniently leave those out in my interpreter. It means that in the commands input file, there should not be any of such instructions. If they are there, if the instructions are written correctly, my interpreter should never reach those lines anyway, I hope.

# Setting Up the VM

Before starting to interpret the commands, I need to setup the memory space, constants and jump labels.

## Memory and Constants

The memory space is represented by a list, with size `memspace` as given from the initialization file. All the slots are assigned `None` to indicate there is nothing in that slot.

```
mem = [None] * memspace
```

Then, for each constant I receive from the initialization file, I will assign it to the memory starting from the last index.

```
index = memspace - 1
while consts:
    const = consts.pop(0)
    mem[index] = const
    index = index - 1
```

## Jump Labels

The jump labels are those characters followed by a colon in the set of instructions. They are used for jumping around when a `JUMP` or `JUMPZ` is encountered. To know where to jump to when a `JUMP` is encountered, I need to first find out the positions of all the labels.

To do this, I run through each instruction in the list, and check for `<char>:` pattern using regex. Once a label is encountered, I store the label as key and the position as value in a `labels` dictionary.

```
labels = {}
p = re.compile("(?P<label>\w+):")
for index,cmd in enumerate(commands):
    m = p.match(cmd)
    if m:
        lbl = m.group("label")
        labels[lbl] = index
```

# Interpreting Each Command

There are only a few commands in the game:

1. INBOX
2. OUTBOX
3. ADD
4. SUB
5. BUMPUP
6. BUMPDN
7. JUMP
8. JUMPZ
9. JUMPN
10. COPYTO
11. COPYFROM

I will interpret every single one, and on top of that I have the `END` command.

Commands like `INBOX` are easy to interpret, because there is no memory involved. However, `ADD`, `BUMPUP`, `COPYTO` etc. will involve the memory space, which is represented as an index or an address reference.

For example, the `ADD` command can come in 2 flavours: `ADD 1` or `ADD [1]`. The first one means to add whatever is at index 1 of memory into the temporary variable (the main character). The second one means to add whatever is at the index pointed by the value at index 1 from the memory into the temporary variable. Okay, still not clear? Visually it means this:

Given the on-the-floor space like this:

```
[ ] [2] [5] [6] [1]
```

## ADD 1

Assume that the main character holds a `3` in hand, the outcome of this command is that `2` is taken from `mem[1]` and added to `3` in hand to give `5`.

## ADD [1]

Assume that the main character holds a `3` in hand, the outcome of this command is that `2` is first taken from `mem[1]`, then `2` becomes the index of the memory slot to read from, and `5` is taken from `mem[2]`, so this added to `3` in hand will give `8`.

For each of the commands that contains the index or address reference, I have created a regex object.

```
sub = re.compile("(\s)*SUB(\s)+\[(?P<addr>\w+)\]|(\s)*SUB(\s)+((?P<index>\w+))")
add = re.compile("(\s)*ADD(\s)+\[(?P<addr>\w+)\]|(\s)*ADD(\s)+((?P<index>\w+))")
bup = re.compile("(\s)*BUMPUP(\s)+\[(?P<addr>\w+)\]|(\s)*BUMPUP(\s)+(?P<index>\w+)")
bdn = re.compile("(\s)*BUMPDN(\s)+\[(?P<addr>\w+)\]|(\s)*BUMPDN(\s)+(?P<index>\w+)")
cpt = re.compile("(\s)*COPYTO(\s)+\[(?P<addr>\w+)\]|(\s)*COPYTO(\s)+(?P<index>\w+)")
cpf = re.compile("(\s)*COPYFROM(\s)+\[(?P<addr>\w+)\]|(\s)*COPYFROM(\s)+(?P<index>\w+)")
```

On top of that, I have also created a few regex objects for interpreting the jumping commands.

```
jpz = re.compile("(\s)*JUMPZ(\s)+(?P<label>\w+)")
jpn = re.compile("(\s)*JUMPN(\s)+(?P<label>\w+)")
jmp = re.compile("(\s)*JUMP(\s)+(?P<label>\w+)")
```

# Execution

I have a main loop that keeps moving the instruction `ptr` to read each command, then execute the instruction accordingly. Unless there is a break from the loop, I will always increment the `ptr` value for the next instruction to be executed. I will group the instructions into: I/O, Operations and Jumps for easier discussion.

## I/O

I/O instructions are `INBOX` and `OUTBOX`. These are straightforward.

For `INBOX`, I will get the first element from the `inputs` list. However, if the list is empty, I will break from the loop.

```
if not inputs:
    break
x = inputs.pop(0)
```

For `OUTBOX`, I will simply append the current `x` value to the `outputs` list, and reset `x` to `None`.

```
outputs.append(x)
x = None
```

## Operations

For example, to execute the `ADD` command, I will find out whether to add by value or reference.

```
m = add.match(cmd)
if m.group("addr"):
    i = get_addr(m)
    addr = get_val_from_mem(mem, i)
    x = add_raw(x, get_val_from_mem(mem, addr))
else:
    i = get_index(m)
    x = add_raw(x, get_val_from_mem(mem, i))
```

If the `ADD [i]` pattern is matched, then I will use `i` to get the value from `get_val_from_mem(mem, i)`, and then add `get_val_from_mem(mem, addr)` to `x` and assign back to `x`.

Otherwise, I just directly add `get_val_from_mem(mem, i)` to `x` and assign back to `x`.

Basically, most of the commands work this way, so I will not elaborate further on every command. Except for `COPYTO` command, all execution will end up with the result of the operation being assigned back to `x`.

I will talk a little about `add_raw` in the later sections.

## Jumps

Another set of commands that works alongside operations is the jumping commands.

Previously when the VM is setup, we already store the indexes of all the labels. When I actually interpret the commands and encounter a jump instruction, I will look up in the `labels` dictionary for the value of the label and get its position, then I set `ptr` to the position. The next instruction to get interpreted will be at index `ptr + 1` in the commands list.

```
m = jmp.match(cmd)
lbl = m.group("label")
ptr = labels[lbl]
```

Something to note about `JUMPN` and `JUMPZ` is that the checking of zero or negative value is based on the current `x` value, so when these instructions are encountered, I just call `cmp_raw(x, "lt", 0)` and `cmp_raw(x, "eq", 0)` respectively, then find the jump label if the condition is true.

I will talk more about `cmp_raw` in the following section.

# Dealing with Characters

One problem I encountered when writing the interpreter was that I can't directly execute `SUB` or jump comparisons on characters using Python. Instead, I have to do something to convert the characters into integer values.

To do that, I have to provide functions to do arithmetic operations and comparison on integers/characters.

## Addition

In the HRM game, adding characters is invalid, so I have to do some checking when trying to add 2 values.

```
def add_raw(left, right):
    if type(left) != type(right):
        print_error("Unable to add values of different types %s and %s" % (type(left), type(right)))
        exit(1)
    try:
        return int(left) + int(right)
    except ValueError:
        print_error("Unable to add characters together")
        exit(1)
```

In this function, I will first check that the 2 values are of the same type, and try to return the addition of the integer values. If `ValueError` is raised, it means they are characters, and I will exit the program with an error.

## Subtraction

However, it is a valid operation to subtract characters but not a mix of both characters and integers.

```
def sub_raw(left, right):
    if type(left) != type(right):
        print_error("Unable to sub values of different types %s and %s" % (type(left), type(right)))
        exit(1)
    try:
        return int(left) - int(right)
    except ValueError:
        return ord(left) - ord(right)
```

In this function, I will again make sure the 2 values are of the same type. Then, it will either return the difference of the integer values or the ASCII values of characters.

Note that in the game itself, after subtracting 2 characters, the result given back to the main character is an integer instead of a character, so we will also keep it that way here.

## Comparison

For comparison, there is no restriction on whether the 2 values are of the same type, it is valid to run `JUMPZ` when holding a character.

```
def cmp_raw(left, op, right):
    try:
        left = int(left)
    except ValueError:
        left = ord(left)
    try:
        right = int(right)
    except ValueError:
        right = ord(right)
    return compare(left, op, right)
```

In this function, I will try to get the integer value of the input, else I will return the ASCII value of the character input. Then, I will pass the integer values into the `compare` function to get the result.

```
def compare(left, op, right):
    if op == "eq":
        return left == right
    elif op == "ne":
        return left != right
    elif op == "lt":
        return left < right
    elif op == "gt":
        return left > right
    elif op == "lte":
        return left <= right
    elif op == "gte":
        return left >= right
    print_error("Invalid operation %s" % op)
    exit(1)
```

I have implemented all the comparators although we only use `eq` and `lt` in the game.

# Know Issues

Here we have a pretty complete working interpreter for HRM instructions. However, there are still some parts which can be improved upon.

1. In the HRM game, there is no `END` instruction for the program to terminate. However, my interpreter cannot work properly without the `END` instruction. I will try to think of a way to do without that instruction.

2. There are a lot of error checks that I have left out. I will try to put those in slowly when I have time.

3. Other than using a file to supply inputs to the interpreter, I also want to allow using the command line for inputs. Will come to that again when I have time.

4. Speaking of files, I also need to do some checking on the data format given by the files.

5. The generated plain text instructions by HRM actually contains `DEFINE` instructions for the in game comments and on-the-floor labels. In my example, I have deliberately removed those instructions. By right, the interpreter will ignore those instructions, but if the actual instructions are not written properly, there might be a chance that the interpreter will reach the `DEFINE` instructions, and then it will run into an infinite loop because there is no instruction that will change the `ptr` value. So, to be safe, it is probably better that I do not include those instructions in the list when I read from file.

# Conclusion

Writing the interpreter has been as fun an activity as playing the game itself. Through this small project, it gives me more insights into how the people at Tomorrow Corp has created the game.

The next challenge from my mentor is to write a compiler from Python into HRM instructions. But I guess I will leave it to a much later time, because that sounds like a pretty big project which requires me to do syntax parsing and all those compiler concepts which I have long forgotten ever since I graduated.

